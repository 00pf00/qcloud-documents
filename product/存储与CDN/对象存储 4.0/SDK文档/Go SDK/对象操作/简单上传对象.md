### 简单上传对象

#### 功能说明

上传一个 Object（文件/对象）至存储桶（PUT Object）。最大支持5GB（含），5GB以上的对象请使用 [分块上传](#.E5.88.86.E5.9D.97.E4.B8.8A.E4.BC.A0.E5.AF.B9.E8.B1.A1) 或 [高级接口](#.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3.EF.BC.88.E6.8E.A8.E8.8D.90.EF.BC.89) 上传。支持简单上传对象、创建文件夹、批量上传操作。


#### 方法原型

```go
func (s *ObjectService) Put(ctx context.Context, key string, r io.Reader, opt *ObjectPutOptions) (*Response, error)
func (s *ObjectService) PutFromFile(ctx context.Context, name string, filePath string, opt *ObjectPutOptions) (*Response, error)
```

#### 请求示例1：上传对象

[//]: # (.cssg-snippet-put-object)
```go
// Case1 使用 Put 上传对象
key := "exampleobject"
f, err := os.Open("../test")
opt := &cos.ObjectPutOptions{
    ObjectPutHeaderOptions: &cos.ObjectPutHeaderOptions{
        ContentType: "text/html",
    },
    ACLHeaderOptions: &cos.ACLHeaderOptions{
        // 如果不是必要操作，建议上传文件时不要给单个文件设置权限，避免达到限制。若不设置默认继承桶的权限。
        XCosACL: "private",
    },
}
_, err = client.Object.Put(context.Background(), key, f, opt)
if err != nil {
    panic(err)
}

// Case 2 使用 PUtFromFile 上传本地文件到COS
filepath := "./test"
_, err = client.Object.PutFromFile(context.Background(), key, filepath, opt)
if err != nil {
    panic(err)
}

// Case 3 上传 0 字节文件, 设置输入流长度为 0 
_, err = client.Object.Put(context.Background(), key, strings.NewReader(""), nil)
if err != nil {
    // ERROR
}
```

#### 请求示例2：创建文件夹

COS 上可以将以 '/' 分隔的对象路径看做虚拟文件夹，根据此特性，可以上传一个空的流，并且命名以 '/' 结尾，可实现在 COS 上创建一个空文件夹。
```go
// 文件夹名称
name := "folder/"
// 传递大小为0的输入流
_, err := c.Object.Put(context.Background(), name, strings.NewReader(""), nil)
if err != nil {
	// ERROR
}
```

#### 请求示例3：上传到虚拟目录

上传由 '/' 分隔的对象名，自动创建包含文件的文件夹。想要在此文件夹中添加新文件时，只需要在上传文件至 COS 时，将 Key 填写为此目录前缀即可。
```go
dir := "exampledir/"
filename := "exampleobject"
key := dir + filename
f := strings.NewReader("test file")
_, err = c.Object.Put(context.Background(), key, f, nil)
if err != nil {
    // ERROR
}
```

#### 请求示例4：查看上传进度

```go
type SelfListener struct {
}
// 自定义进度回调，需要实现 ProgressChangedCallback 方法
func (l *SelfListener) ProgressChangedCallback(event *cos.ProgressEvent) {
    switch event.EventType {
    case cos.ProgressDataEvent:
        fmt.Printf("\r[ConsumedBytes/TotalBytes: %d/%d, %d%%]",
                    event.ConsumedBytes, event.TotalBytes, event.ConsumedBytes*100/event.TotalBytes)
    case cos.ProgressFailedEvent:
        fmt.Printf("\nTransfer Failed: %v", event.Err)
    }
}
func main() {
    // 初始化
    ...
 
    // Case 1 通过默认回调查看上传进度
    key := "exampleobject"
    f, err := os.Open("../test")
    opt := &cos.ObjectPutOptions{
        ObjectPutHeaderOptions: &cos.ObjectPutHeaderOptions{
            ContentType: "text/html",
            // 设置默认的进度回调函数
            Listener:    &cos.DefaultProgressListener{},
        },
        ACLHeaderOptions: &cos.ACLHeaderOptions{
            // 如果不是必要操作，建议上传文件时不要给单个文件设置权限，避免达到限制。若不设置默认继承桶的权限。
            XCosACL: "private",
        },
    }
    _, err = client.Object.Put(context.Background(), key, f, opt)
    if err != nil {
        panic(err)
    }

    // Case 2 通过自定义方式查看上传进度
    opt.Listener = &SelfListener{}
    filepath := "./test"
    _, err = client.Object.PutFromFile(context.Background(), key, filepath, opt)
    if err != nil {
        panic(err)
    }
}

```

#### 请求示例5：多线程批量上传

```
func upload(wg *sync.WaitGroup, c *cos.Client, files <-chan string) {
    defer wg.Done()
    for file := range files {
        name := "folder/" + file
	fd, err := os.Open(file)
        if err != nil {
            //ERROR
            continue
        }
        _, err = c.Object.Put(context.Background(), name, fd, nil)
        if err != nil {
            //ERROR
        }
    }
}
func main() {
        u, _ := url.Parse("https://examplebucket-1250000000.cos.ap-guangzhou.myqcloud.com")
        b := &cos.BaseURL{BucketURL: u}
        c := cos.NewClient(b, &http.Client{
                Transport: &cos.AuthorizationTransport{
                        SecretID:  os.Getenv("SECRETID"),
                        SecretKey: os.Getenv("SECRETKEY"),
                },
        })
	// 多线程批量上传文件
        filesCh := make(chan string, 2)
        filePaths := []string{"test1", "test2", "test3"}
        var wg sync.WaitGroup
        threadpool := 2
        for i := 0; i < threadpool; i++ {
                wg.Add(1)
                go upload(&wg, c, filesCh)
        }
        for _, filePath := range filePaths {
                filesCh <- filePath
        }
        close(filesCh)
        wg.Wait()
}
```

#### 参数说明

```go
type ObjectPutOptions struct {
    *ACLHeaderOptions       
    *ObjectPutHeaderOptions 
}
type ACLHeaderOptions struct {
    XCosACL              string                           
    XCosGrantRead        string
    XCosGrantWrite       string 
    XCosGrantFullControl string                                           
} 
type ObjectPutHeaderOptions struct {
    CacheControl       string 
    ContentDisposition string 
    ContentEncoding    string 
    ContentType        string 
    ContentLength      int64  
    Expires            string 
    // 自定义的 x-cos-meta-* header
    XCosMetaXXX        *http.Header 
    XCosStorageClass   string      
    XCosTrafficLimit   int
    Listener           ProgressListener
}
```

| 参数名称             | 参数描述                                                     | 类型        | 是否必填 |
| -------------------- | ------------------------------------------------------------ | ----------- | -------- |
| r                    | 上传文件的内容，可以为文件流或字节流，当 r 不是`bytes.Buffer/bytes.Reader/strings.Reader`时，必须指定`opt.ObjectPutHeaderOptions.ContentLength` | io.Reader   | 是       |
| key                  | 对象键（Key）是对象在存储桶中的唯一标识。例如，在对象的访问域名`examplebucket-1250000000.cos.ap-guangzhou.myqcloud.com/doc/pic.jpg`中，对象键为 doc/pic.jpg | string      | 是       |
| XCosACL              | 设置文件的 ACL，例如 private，public-read，public-read-write | string      | 否       |
| XCosGrantFullControl | 赋予被授权者所有的权限。格式：id="[OwnerUin]"                | string      | 否       |
| XCosGrantRead        | 赋予被授权者读的权限。格式：id="[OwnerUin]"                  | string      | 否       |
| XCosStorageClass     | 设置文件的存储类型，STANDARD、STANDARD_IA、ARCHIVE，默认值：STANDARD | string      | 否       |
| Expires              | 设置 Content-Expires                                         | string      | 否       |
| CacheControl         | 缓存策略，设置 Cache-Control                                 | string      | 否       |
| ContentType          | 内容类型，设置 Content-Type                                  | string      | 否       |
| ContentDisposition   | 文件名称，设置 Content-Disposition                           | string      | 否       |
| ContentEncoding      | 编码格式，设置 Content-Encoding                              | string      | 否       |
| ContentLength        | 设置传输长度                                                 | int64       | 否       |
| XCosMetaXXX          | 用户自定义的文件元信息， 必须以 x-cos-meta 开头，否则会被忽略 | http.Header | 否       |
| XCosTrafficLimit     | 设置单链接限速                                               | int         | 否       |
| Listener             | 进度回调接口                                                 | Struct      | 否       |

#### 返回结果说明

```go
{
    'ETag': 'string',
    'x-cos-expiration': 'string'
}
```

通过返回结果 Response 获取。

```go
resp, err := client.Object.Put(context.Background(), key, f, nil)
etag := resp.Header.Get("ETag")
exp := resp.Header.Get("x-cos-expiration")
```


| 参数名称         | 参数描述                         | 类型   |
| ---------------- | -------------------------------- | ------ |
| ETag             | 上传文件的 MD5 值                | string |
| x-cos-expiration | 设置生命周期后，返回文件过期规则 | string |
